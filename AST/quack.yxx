/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "AST.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
    AST::ASTNode *node;
    AST::Block *block;
    AST::Ident *ident;
    AST::Arg *arg;
    AST::Class *clazz;
    AST::Stub *stub;
}

/* Start tokens */
%token CLASS
%token DEF
%token EXTENDS
%token IF
%token ELIF
%token ELSE
%token WHILE
%token RETURN
%token TYPECASE
%token ATLEAST
%token ATMOST
%token EQUALS
%token AND
%token OR
%token NOT
%token <str> IDENT
%token <num> INT_LIT
%token <str> STRING_LIT
%token NEG

%left AND NOT OR
%left EQUALS ATMOST ATLEAST '>' '<'
%left '+' '-'
%left '*' '/'
%left '.'

Abstract syntax tree nodes
%type <block> program classes opt_classes args formal_args opt_statements statements opt_methods methods 
%type <ident> opt_extends
%type <arg> arg
%type <clazz> class
%type <stub> statement method


// Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).
// %left MINUS PLUS
// %left TIMES DIV

%%

/* A program is a sequence of zero or more class definitions
*  followed by zero or more statements
*/
program: opt_classes opt_statements {
       $$ = new AST::Block();
       $$ -> append($1);
       $$ -> append($2);
       *root = $$;
       }; 

/* Zero or more class definitions */
opt_classes: classes { $$ = $1; }
       | %empty { };

classes: classes class { 
       $$ = $1;
       $$ -> append($2); }
       | class { 
       $$ = new AST::Block();
       $$ -> append($1);
       };

/* Zero or more statments */
opt_statements: statements { $$ = $1; }
          | %empty { $$ = new AST::Block(); };
statements: statements statement { $$ = $1; $1 -> append($2); };
          | statement { $$ = new AST::Block(); $$ -> append($1); };

/* Classes */
class: CLASS IDENT '(' formal_args ')' opt_extends '{' opt_statements opt_methods '}' { 
        $$ = new AST::Class(new AST::Ident($2), $6);
        $$ -> args_ = $4;
        $$ -> stmts_ = $8;
        $$ -> methods_ = $9;
     };

formal_args: args   { $$ = $1; }
           | %empty { $$ = new AST::Block(); };

args: arg         { $$ = new AST::Block(); $$ -> append($1); }
    | args ',' arg { $$ = $1; $1 -> append($3); }

arg: IDENT ':' IDENT { $$ = new AST::Arg(new AST::Ident($1), new AST::Ident($3)); };

opt_extends: EXTENDS IDENT { }
                | %empty { };


/* Methods */

opt_methods: methods { $$ = $1; }
           | %empty { $$ = new AST::Block(); };

methods: methods method { $$ = $1; $$ -> append($2); }
       | method {$$ = new AST::Block(); $$ -> append($1); };

method: DEF IDENT '(' formal_args ')' opt_ident statement_block { $$ = new AST::Stub("NI: Method"); };

opt_ident: ':' IDENT
         | %empty { };

/* Statements */

statement_block: '{' opt_statements '}' { };

/* If-Elif-Else */

statement: IF r_expr statement_block more_elif opt_else { };

more_elif: more_elif ELIF r_expr statement_block
         | %empty { };

opt_else: ELSE statement_block
        | %empty

/* While */

statement: WHILE r_expr statement_block { $$ = new AST::Stub("NI: While"); };

/* Assignments */

statement: l_expr opt_ident '=' r_expr ';' { $$ = new AST::Stub("NI: Assign"); };

/* L_Expression */

l_expr: IDENT
      | r_expr '.' IDENT { };

/* Bare Expressions */

statement: r_expr ';' { $$ = new AST::Stub("NI: Bare expr"); };

/* Constants */

r_expr: STRING_LIT { };

r_expr: INT_LIT { };

r_expr: l_expr { };

/* Binary Operators */

r_expr: r_expr '+' r_expr { };

r_expr: r_expr '-' r_expr { };

r_expr: r_expr '*' r_expr { };

r_expr: r_expr '/' r_expr { };

/* Unary Operators */

r_expr: '-' r_expr { };

r_expr: '(' r_expr ')' { };

/* Logical Expressions */

r_expr: r_expr EQUALS r_expr { };

r_expr: r_expr ATLEAST r_expr { };

r_expr: r_expr ATMOST r_expr { };

r_expr: r_expr '<' r_expr { };

r_expr: r_expr '>' r_expr { };

r_expr: r_expr AND r_expr { };

r_expr: r_expr OR r_expr { };

r_expr: NOT r_expr { };

/* Method Invocation */

r_expr: r_expr '.' IDENT '(' actual_args ')' { };

actual_args: r_expr seq_r_expr 
           | %empty { };

seq_r_expr: seq_r_expr ',' r_expr
        | %empty { };

r_expr: IDENT '(' actual_args ')' { };

/* Return */

statement: RETURN opt_r_expr ';' { $$ = new AST::Stub("NI: Return"); };

opt_r_expr: r_expr
          | %empty { };

/* Typecase */

statement: TYPECASE r_expr '{' type_alt '}' { $$ = new AST::Stub("NI: typecase"); };

type_alt: type_alt IDENT ':' IDENT statement_block
        | %empty { };

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}
