/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
    AST::ASTNode* node;
    // block needs a more explicit type to use the 'append' method
    AST::Block* block;
}

/* Start tokens */
%token CLASS
%token DEF
%token EXTENDS
%token IF
%token ELIF
%token ELSE
%token WHILE
%token RETURN
%token TYPECASE
%token ATLEAST
%token ATMOST
%token EQUALS
%token AND
%token OR
%token NOT
%token <str> IDENT
%token <num> INT_LIT
%token <str> STRING_LIT
%token NEG

%left AND NOT OR
%left EQUALS ATMOST ATLEAST '>' '<'
%left '+' '-'
%left '*' '/'
%left '.'

// Abstract syntax tree nodes
// %type <node> expr leaf program stmt assignment
// %type <block> block if_alternatives
// %type <node> ifstmt

// Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).
// %left MINUS PLUS
// %left TIMES DIV

%%

/* A program is a sequence of zero or more class definitions
*  followed by zero or more statements
*/
program: classes statements { std::cout << "Parsed Successfully" << std::endl; } ;

/* Zero or more class definitions */
classes: classes class 
       | %empty { };

/* Zero or more statments */
statements: statements statement
          | %empty { };

/* Classes */
class: class_signature class_body { };

class_signature: CLASS IDENT '(' formal_args ')' opt_extends { };

formal_args: IDENT ':' IDENT more_idents
           | %empty { };

opt_extends: EXTENDS IDENT
                | %empty { };

more_idents: more_idents ',' IDENT ':' IDENT
                | %empty { };

class_body: '{' statements methods '}' { };

/* Methods */

methods: methods method
       | %empty { };

method: DEF IDENT '(' formal_args ')' opt_ident statement_block { };

opt_ident: ':' IDENT
         | %empty { };

/* Statements */

statement_block: '{' statements '}' { };

/* If-Elif-Else */

statement: IF r_expr statement_block more_elif opt_else { };

more_elif: more_elif ELIF r_expr statement_block
         | %empty { };

opt_else: ELSE statement_block
        | %empty

/* While */

statement: WHILE r_expr statement_block { };

/* Assignments */

statement: l_expr opt_ident '=' r_expr ';' { };

/* L_Expression */

l_expr: IDENT
      | r_expr '.' IDENT { };

/* Bare Expressions */

statement: r_expr ';' { };

/* Constants */

r_expr: STRING_LIT { };

r_expr: INT_LIT { };

r_expr: l_expr { };

/* Binary Operators */

r_expr: r_expr '+' r_expr { };

r_expr: r_expr '-' r_expr { };

r_expr: r_expr '*' r_expr { };

r_expr: r_expr '/' r_expr { };

/* Unary Operators */

r_expr: '-' r_expr { };

r_expr: '(' r_expr ')' { };

/* Logical Expressions */

r_expr: r_expr EQUALS r_expr { };

r_expr: r_expr ATLEAST r_expr { };

r_expr: r_expr ATMOST r_expr { };

r_expr: r_expr '<' r_expr { };

r_expr: r_expr '>' r_expr { };

r_expr: r_expr AND r_expr { };

r_expr: r_expr OR r_expr { };

r_expr: NOT r_expr { };

/* Method Invocation */

r_expr: r_expr '.' IDENT '(' actual_args ')' { };

actual_args: r_expr seq_r_expr 
           | %empty { };

seq_r_expr: seq_r_expr ',' r_expr
        | %empty { };

r_expr: IDENT '(' actual_args ')' { };

/* Return */

statement: RETURN opt_r_expr ';' { };

opt_r_expr: r_expr
          | %empty { };

/* Typecase */

statement: typecase { };

typecase: TYPECASE r_expr '{' type_alt '}' { };

type_alt: type_alt IDENT ':' IDENT statement_block
        | %empty { };

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}
