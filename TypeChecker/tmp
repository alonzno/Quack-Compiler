/*
 * Stubs for built-in classes of Quack. We do not generate code
 * for these.  These are used only for static semantics checking.
 * Their real code is hand-written C code.
 */

 class Obj() {
    def PRINT() { }
    def STR() { }
    def EQUALS(other: Obj): Boolean {} // Default is object identity
 }

 class Nothing() { }

 class String() {
    def PLUS(other: String): String { }      // +
    def EQUALS(other: String): Boolean { }   // ==
    def ATMOST(other: String): Boolean { }   // <=
    def LESS(other: String): Boolean { }     // <
    def ATLEAST(other: String): Boolean { }  // >=
    def MORE(other: String): Boolean { }     // >
 }

 class Boolean() { }

 class Int() {
    def PLUS(right: Int): Int {}   // this + right
    def TIMES(right: Int): Int {}  // this * right
    def MINUS(right: Int): Int {}  // this - right
    def DIVIDE(right: Int): Int {}    // this / right
    def ATMOST(other: Int): Boolean { }     // <=
    def LESS(other: Int): Boolean { }       // <
    def ATLEAST(other: Int): Boolean { }    // >=
    def MORE(other: Int): Boolean { }       // >
 }
/**
 * How should one perform type inference 
 * for variable x in this program? 
 *
 * Iterate to a fixed point (abstract interpretation)? 
 * Somehow short-circuit the walk up the type system? 
 * Impose some restriction that prevents this problem? 
 */

class C1()  extends Obj {
   def foo() : Obj {
       return Obj();
   }
}

class C2() extends C3 {
   def foo() : C1 {
        return C1();   /* Conforms to C1.foo() */
   }
}
class C3() extends C2 {
   def foo() : C2 {
        return C2();   /* Conforms to C2.foo() */
   }
}

