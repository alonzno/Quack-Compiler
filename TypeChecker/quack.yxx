/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "AST.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::Program** root }

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
    AST::ASTNode *node;
    AST::Block *block;
    AST::Ident *ident;
    AST::Arg *arg;
    AST::Class *clazz;
    AST::Assign *assign;
    AST::FormalArgs *formal_args;
    AST::ActualArgs *actual_args;
    AST::R_Expr *r_expr;
    AST::L_Expr *l_expr;
    AST::Method *method;
    AST::Statement *stmt;
    AST::If_Else *if_else;
    AST::Typecase *typecase;
    AST::TypeAlt *typealt;
    std::vector<AST::If_Else *> *elif_block;
    std::vector<AST::Method *> *methods;
    std::vector<AST::Class *> *classes;
    std::vector<AST::TypeAlt *> *typealts;
}

/* Start tokens */
%token CLASS
%token DEF
%token EXTENDS
%token IF
%token ELIF
%token ELSE
%token WHILE
%token RETURN
%token TYPECASE
%token ATLEAST
%token ATMOST
%token EQUALS
%token AND
%token OR
%token NOT
%token <str> IDENT
%token <num> INT_LIT
%token <str> STRING_LIT
%token NEG

%left AND OR NOT
%left EQUALS ATMOST ATLEAST '>' '<'
%left '+' '-'
%left '*' '/'
%left '.'

// Abstract syntax tree nodes
%type <block> opt_statements statements statement_block opt_else 
%type <typealts> opt_type_alt more_type_alt
%type <classes> classes opt_classes
%type <methods> opt_methods methods
%type <ident> opt_extends opt_ident
%type <arg> arg
%type <formal_args> formal_args opt_formal_args
%type <actual_args> actual_args seq_r_expr 
%type <clazz> class
%type <method> method
%type <r_expr> r_expr opt_r_expr
%type <l_expr> l_expr
%type <stmt> statement
%type <if_else> if_statement
%type <typealt> type_alt
%type <elif_block> more_elif opt_elif

%%

/* A program is a sequence of zero or more class definitions
*  followed by zero or more statements
*/
program: opt_classes opt_statements {
       *root = new AST::Program($1, $2);
       }; 

/* Zero or more class definitions */
opt_classes: classes { $$ = $1; }
       | %empty { 
       $$ = new std::vector<AST::Class *>(); 
       };

classes: classes class { 
       $$ = $1;
       $$ -> push_back($2);
       }
       | class { 
       $$ = new std::vector<AST::Class *>();
       $$ -> push_back($1);
       };

/* Zero or more statments */
opt_statements: statements { $$ = $1; }
          | %empty { 
          $$ = new AST::Block(); 
          $$ -> setLine(@$.begin.line, @$.begin.column);
          };
statements: statements statement { 
          $$ = $1; 
          $$ -> append($2); 
          };
          | statement { 
          $$ = new AST::Block(); 
          $$ -> setLine(@$.begin.line, @$.begin.column);
          $$ -> append($1); 
          };

/* Classes */
class: CLASS IDENT '(' opt_formal_args ')' opt_extends '{' opt_statements opt_methods '}' { 
        $$ = new AST::Class(new AST::Ident($2), $6, $4, $8, $9);
        $$ -> setLine(@$.begin.line, @$.begin.column);
     };

opt_formal_args: formal_args   { $$ = $1; }
           | %empty { 
           $$ = new AST::FormalArgs(); 
           $$ -> setLine(@$.begin.line, @$.begin.column);
           };

formal_args: arg         { 
    $$ = new AST::FormalArgs(); 
    $$ -> setLine(@$.begin.line, @$.begin.column);
    $$ -> append($1); 
    }
    | formal_args ',' arg { 
    $$ = $1; 
    $$ -> append($3); 
    }

arg: IDENT ':' IDENT { 
   $$ = new AST::Arg(new AST::Ident($1), new AST::Ident($3)); 
   $$ -> setLine(@$.begin.line, @$.begin.column);
   };

opt_extends: EXTENDS IDENT { 
                $$ = new AST::Ident($2);
                $$ -> setLine(@$.begin.line, @$.begin.column);
                }
                | %empty { 
                $$ = new AST::Ident(""); 
                $$ -> setLine(@$.begin.line, @$.begin.column);
                };


/* Methods */

opt_methods: methods { $$ = $1; }
           | %empty { 
           $$ = new std::vector<AST::Method *>(); 
           };

methods: methods method { 
       $$ = $1; 
       $$ -> push_back($2); 
       }
       | method {
       $$ = new std::vector<AST::Method *>(); 
       $$ -> push_back($1); 
       };

method: DEF IDENT '(' opt_formal_args ')' opt_ident statement_block { 
      AST::Ident *method_name = new AST::Ident($2);
      method_name -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Method(method_name, $6, $4, $7); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

opt_ident: ':' IDENT { 
         $$ = new AST::Ident($2); 
         $$ -> setLine(@$.begin.line, @$.begin.column);
         }
         | %empty { 
         $$ = new AST::Ident(""); 
         $$ -> setLine(@$.begin.line, @$.begin.column);
         };

/* Statements */

statement_block: '{' opt_statements '}' { $$ = $2; };

/* If-Elif-Else */
statement: if_statement { $$ = $1; }

if_statement: IF r_expr statement_block opt_elif opt_else { 
         $$ = new AST::If_Else($2, $3, NULL); 
         std::vector<AST::If_Else *> *elif_block = $4;
         AST::Block *final_else = $5;
         
         AST::If_Else *current_if = $$;
         AST::Block *block_wrapper;

         int num_if = elif_block -> size();
         for (int i = 0; i < num_if; i++) {
            block_wrapper = new AST::Block();
            block_wrapper -> append((*elif_block)[i]);
            current_if -> setElseBlock(block_wrapper);
            current_if = (*elif_block)[i];
         }
         current_if -> setElseBlock(final_else);
         
         delete elif_block;

         $$ -> setLine(@$.begin.line, @$.begin.column);
         };

opt_elif: more_elif { $$ = $1; }
         | %empty { 
         $$ = new std::vector<AST::If_Else *>();
         };

more_elif: more_elif ELIF r_expr statement_block { 
         $$ = $1; 
         AST::If_Else *if_else = new AST::If_Else($3, $4, NULL); 
         if_else -> setLine(@$.begin.line, @$.begin.column);
         $$ -> push_back(if_else); 
         }
         | ELIF r_expr statement_block { 
         $$ = new std::vector<AST::If_Else *>();
         AST::If_Else *if_else = new AST::If_Else($2, $3, NULL); 
         if_else -> setLine(@$.begin.line, @$.begin.column);
         $$ -> push_back(if_else); 
         }


opt_else: ELSE statement_block { $$ = $2; }
        | %empty { 
        $$ = new AST::Block(); 
        $$ -> setLine(@$.begin.line, @$.begin.column);
        }

/* While */

statement: WHILE r_expr statement_block { 
         $$ = new AST::While($2, $3); 
         $$ -> setLine(@$.begin.line, @$.begin.column);
         };

/* Assignments */

statement: l_expr opt_ident '=' r_expr ';' { 
         $$ = new AST::Assign($1, $2, $4); 
         $$ -> setLine(@$.begin.line, @$.begin.column);
         };

/* L_Expression */

l_expr: IDENT { 
      $$ = new AST::L_Expr(new AST::Ident($1)); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      }
      | r_expr '.' IDENT { 
      $$ = new AST::L_Expr($1, new AST::Ident($3)); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

/* Bare Expressions */

statement: r_expr ';' { $$ = $1; };

/* Constants */

r_expr: STRING_LIT {  
      $$ = new AST::StrConst($1); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: INT_LIT { 
      $$ = new AST::IntConst($1); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: l_expr {  $$ = $1; };

/* Binary Operators */

r_expr: r_expr '+' r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("PLUS"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr '-' r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("MINUS"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column); 
      };

r_expr: r_expr '*' r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("TIMES"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr '/' r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("DIVIDE"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

/* Unary Operators */

r_expr: '-' r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($2);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call(new AST::IntConst(0), new AST::Ident("MINUS"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: '(' r_expr ')' { $$ = $2; };

/* Logical Expressions */

r_expr: r_expr EQUALS r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("EQUALS"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr ATLEAST r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("ATLEAST"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr ATMOST r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("ATMOST"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr '<' r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("LESS"), args); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr '>' r_expr { 
      AST::ActualArgs *args = new AST::ActualArgs();
      args -> append($3);
      args -> setLine(@$.begin.line, @$.begin.column);
      $$ = new AST::Call( $1, new AST::Ident("MORE"), args);
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr AND r_expr { $$ = new AST::And($1, $3); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

r_expr: r_expr OR r_expr { $$ = new AST::Or($1, $3); };

r_expr: NOT r_expr { $$ = new AST::Neg($2); };

/* Method Invocation */

r_expr: r_expr '.' IDENT '(' actual_args ')' { $$ = new AST::Call($1, new AST::Ident($3), $5); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

actual_args: seq_r_expr { $$ = $1; }
           | %empty { 
           $$ = new AST::ActualArgs(); 
           $$ -> setLine(@$.begin.line, @$.begin.column);
           };

seq_r_expr: seq_r_expr ',' r_expr { 
          $$ = $1; 
          $$ -> append($3); 
          }
          | r_expr { 
          $$ = new AST::ActualArgs(); 
          $$ -> setLine(@$.begin.line, @$.begin.column);
          $$ -> append($1); 
          };

r_expr: IDENT '(' actual_args ')' { $$ = new AST::Constructor(new AST::Ident($1), $3); 
      $$ -> setLine(@$.begin.line, @$.begin.column);
      };

/* Return */

statement: RETURN opt_r_expr ';' { 
         $$ = new AST::Return($2); 
         $$ -> setLine(@$.begin.line, @$.begin.column);
         };

opt_r_expr: r_expr { $$ = $1; }
          | %empty { 
          $$ = NULL; 
          };

/* Typecase */

statement: TYPECASE r_expr '{' opt_type_alt '}' { 
         $$ = new AST::Typecase($2, $4); 
         $$ -> setLine(@$.begin.line, @$.begin.column);
         };

opt_type_alt: more_type_alt { $$ = $1; }
            | %empty { 
            $$ = new std::vector<AST::TypeAlt *>(); 
            };
more_type_alt: more_type_alt type_alt { 
             $$ = $1; 
             $$ -> push_back($2);
             }
        | type_alt {
        $$ = new std::vector<AST::TypeAlt *>(); 
        $$ -> push_back($1);
        };
type_alt: IDENT ':' IDENT statement_block {
            AST::Arg *arg = new AST::Arg(new AST::Ident($1), new AST::Ident($3));
            $$ = new AST::TypeAlt(arg, $4);
            $$ -> setLine(@$.begin.line, @$.begin.column);
        }

%%
#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}
