// lex.yy.cpp generated by reflex 1.0.9 from lexerspec.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_outfile             lex.yy.cpp

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "lexerspec.l"

    #include <fstream>


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int dq = 1;
  static const int sq = 2;
  virtual int lex();
  int lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int Lexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL("(?m)([\"])|(['])");
  static const reflex::Pattern PATTERN_dq("(?m)([^\"']*)|([\"])|(['])");
  static const reflex::Pattern PATTERN_sq("(?m)([^']*)|(['])");
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 8: ["]
#line 8 "lexerspec.l"
{ push_state(dq); out() << "&ldquo;"; }
            break;
          case 2: // rule at line 9: [']
#line 9 "lexerspec.l"
{ push_state(sq); out() << "&lsquo;"; }
            break;
        }
        break;
      case dq:
        matcher().pattern(PATTERN_dq);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 10: [^"']*
#line 10 "lexerspec.l"
{ out() << text(); }
            break;
          case 2: // rule at line 12: ["]
#line 12 "lexerspec.l"
{ out()<< "&rdquo;"; pop_state(); }
            break;
          case 3: // rule at line 13: [']
#line 13 "lexerspec.l"
{ push_state(sq); out() << "&lsquo;"; }
            break;
        }
        break;
      case sq:
        matcher().pattern(PATTERN_sq);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 11: [^']*
#line 11 "lexerspec.l"
{ out() << text(); }
            break;
          case 2: // rule at line 14: [']
#line 14 "lexerspec.l"
{ pop_state(); out() << "&rsquo;"; }

            break;
        }
        break;
      default:
        return 0;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 17 "lexerspec.l"

int main(int argc, char **argv)
{
    if (argc < 2){
        std::cerr << "Usage: " << argv[0] << " <filename>" << std::endl;
        exit(1);
    }

    std::ifstream input_stream(argv[1], std::ios::binary);
    if (!input_stream.is_open()) {
        std::cerr << "Failed to open" << argv[1] << std::endl;
        exit(2);
    }

    Lexer(input_stream, std::cout ).lex();
}
